Author: aszlig <aszlig@nix.build>
Date:   Fri Oct 20 10:17:44 2017 +0000

    Backport Linux 4.14 fixes against version 5.1.26
    
    This combines the following upstream commits:
    
      * Additions/linux/drm: make vboxvideo work with Linux 4.14.
        bugref:8524: Additions/linux: play nicely with distribution-installed Additions
    
        Changes needed to build against Linux 4.14, applying them to older versions
        too where that will not hurt.
    
        Upstream changeset URL: https://www.virtualbox.org/changeset/69143/vbox
    
      * Additions/linux/drm: remove load_lut call-back removed in 4.14.
        bugref:8524: Additions/linux: play nicely with distribution-installed Additions
    
        The load_lut call-back has been optional since Linux 3.11, which is the oldest
        kernel that we support the drm driver on.  It was removed altogether for
        4.14, so remove it from our source.
    
        Upstream changeset URL: https://www.virtualbox.org/changeset/69525/vbox
    
      * Linux/NetFlt: (bugref:9036) Drop UFO support to prevent compilation issues with Linux kernel 4.14
    
        Upstream changeset URL: https://www.virtualbox.org/changeset/69539/vbox
    
      * VBoxPci-linux.c: use kernel_write instead of vfs_write as of Linux 4.14.
        bugref:9057: VBoxPci: vfs_write() no longer exported by Linux kernel
    
        As of Linux 4.14 vfs_write() is no longer exported for use by modules.  Other
        users have been converted to use kernel_write(), which is a wrapper around
        vfs_write() with some added boiler-plate calls to make it safe to use on
        kernel addresses too.  It seems to me like we should probably already have
        been using kernel_write(), but I prefer to leave that decision to someone who
        knows the code, so this change switches over for 4.14 and later.
    
        Fixes: ticketref:17267:comment:6
    
        Upstream changeset URL: https://www.virtualbox.org/changeset/69744/vbox
    
    I've rebased these commits against revision 62611, because that revision
    seems to be around the time 5.1.26 was released and the upstream project
    unfortunately doesn't use tags.

diff --git a/src/VBox/Additions/linux/drm/vbox_drv.c b/src/VBox/Additions/linux/drm/vbox_drv.c
index 16075a475f..00779a9c9c 100644
--- a/src/VBox/Additions/linux/drm/vbox_drv.c
+++ b/src/VBox/Additions/linux/drm/vbox_drv.c
@@ -248,7 +248,9 @@ static struct drm_driver driver =
     .master_set = vbox_master_set,
     .master_drop = vbox_master_drop,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+# if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
     .set_busid = drm_pci_set_busid,
+# endif
 #endif
 
     .fops = &vbox_fops,
@@ -278,4 +280,4 @@ static int __init vbox_init(void)
-#ifdef CONFIG_VGA_CONSOLE
+#if defined(CONFIG_VGA_CONSOLE) || LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
     if (vgacon_text_force() && vbox_modeset == -1)
         return -EINVAL;
 #endif
@@ -289,11 +291,11 @@ static int __init vbox_init(void)
         if (vc_cons[i].d && vc_cons[i].d->vc_mode == KD_GRAPHICS)
             return -EINVAL;
 
-    return drm_pci_init(&driver, &vbox_pci_driver);
+    return pci_register_driver(&vbox_pci_driver);
 }
 static void __exit vbox_exit(void)
 {
-    drm_pci_exit(&driver, &vbox_pci_driver);
+    pci_unregister_driver(&vbox_pci_driver);
 }
 
 module_init(vbox_init);
diff --git a/src/VBox/Additions/linux/drm/vbox_fb.c b/src/VBox/Additions/linux/drm/vbox_fb.c
index b55860b237..c6cc2445a5 100644
--- a/src/VBox/Additions/linux/drm/vbox_fb.c
+++ b/src/VBox/Additions/linux/drm/vbox_fb.c
@@ -375,23 +375,8 @@ out:
     return ret;
 }
 
-static void vbox_fb_gamma_set(struct drm_crtc *crtc, u16 red, u16 green,
-                   u16 blue, int regno)
-{
-
-}
-
-static void vbox_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
-                   u16 *blue, int regno)
-{
-    *red = regno;
-    *green = regno;
-    *blue = regno;
-}
 
 static struct drm_fb_helper_funcs vbox_fb_helper_funcs = {
-    .gamma_set = vbox_fb_gamma_set,
-    .gamma_get = vbox_fb_gamma_get,
     .fb_probe = vboxfb_create,
 };
 
diff --git a/src/VBox/Additions/linux/drm/vbox_mode.c b/src/VBox/Additions/linux/drm/vbox_mode.c
index 00e95d6f8c..6e5c5e6d0c 100644
--- a/src/VBox/Additions/linux/drm/vbox_mode.c
+++ b/src/VBox/Additions/linux/drm/vbox_mode.c
@@ -145,11 +145,6 @@ static int vbox_set_view(struct drm_crtc *crtc)
     return 0;
 }
 
-static void vbox_crtc_load_lut(struct drm_crtc *crtc)
-{
-
-}
-
 static void vbox_crtc_dpms(struct drm_crtc *crtc, int mode)
 {
     struct vbox_crtc *vbox_crtc = to_vbox_crtc(crtc);
@@ -298,10 +293,8 @@ static const struct drm_crtc_helper_funcs vbox_crtc_helper_funcs = {
     .mode_set = vbox_crtc_mode_set,
     /* .mode_set_base = vbox_crtc_mode_set_base, */
     .disable = vbox_crtc_disable,
-    .load_lut = vbox_crtc_load_lut,
     .prepare = vbox_crtc_prepare,
     .commit = vbox_crtc_commit,
-
 };
 
 static void vbox_crtc_reset(struct drm_crtc *crtc)
diff --git a/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c b/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
index b8c18f3b5c..207484280f 100644
--- a/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
+++ b/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
@@ -722,9 +722,6 @@ static struct sk_buff *vboxNetFltLinuxSkBufFromSG(PVBOXNETFLTINS pThis, PINTNETS
         case PDMNETWORKGSOTYPE_IPV4_TCP:
             fGsoType = SKB_GSO_TCPV4;
             break;
-        case PDMNETWORKGSOTYPE_IPV4_UDP:
-            fGsoType = SKB_GSO_UDP;
-            break;
         case PDMNETWORKGSOTYPE_IPV6_TCP:
             fGsoType = SKB_GSO_TCPV6;
             break;
@@ -1100,7 +1097,7 @@ static bool vboxNetFltLinuxCanForwardAsGso(PVBOXNETFLTINS pThis, struct sk_buff
      * Check the GSO properties of the socket buffer and make sure it fits.
      */
     /** @todo Figure out how to handle SKB_GSO_TCP_ECN! */
-    if (RT_UNLIKELY( skb_shinfo(pSkb)->gso_type & ~(SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_TCPV6 | SKB_GSO_TCPV4) ))
+    if (RT_UNLIKELY( skb_shinfo(pSkb)->gso_type & ~(SKB_GSO_DODGY | SKB_GSO_TCPV6 | SKB_GSO_TCPV4) ))
     {
         Log5(("vboxNetFltLinuxCanForwardAsGso: gso_type=%#x\n", skb_shinfo(pSkb)->gso_type));
         return false;
@@ -1393,7 +1390,7 @@ static void vboxNetFltLinuxForwardToIntNet(PVBOXNETFLTINS pThis, struct sk_buff
         Log3(("vboxNetFltLinuxForwardToIntNet: skb len=%u data_len=%u truesize=%u next=%p nr_frags=%u gso_size=%u gso_seqs=%u gso_type=%x frag_list=%p pkt_type=%x ip_summed=%d\n",
               pBuf->len, pBuf->data_len, pBuf->truesize, pBuf->next, skb_shinfo(pBuf)->nr_frags, skb_shinfo(pBuf)->gso_size, skb_shinfo(pBuf)->gso_segs, skb_shinfo(pBuf)->gso_type, skb_shinfo(pBuf)->frag_list, pBuf->pkt_type, pBuf->ip_summed));
 # ifdef VBOXNETFLT_WITH_GSO_RECV
-        if (   (skb_shinfo(pBuf)->gso_type & (SKB_GSO_UDP | SKB_GSO_TCPV6 | SKB_GSO_TCPV4))
+        if (   (skb_shinfo(pBuf)->gso_type & (SKB_GSO_TCPV6 | SKB_GSO_TCPV4))
             && vboxNetFltLinuxCanForwardAsGso(pThis, pBuf, fSrc, &GsoCtx) )
             vboxNetFltLinuxForwardAsGso(pThis, pBuf, fSrc, &GsoCtx);
         else
@@ -1524,17 +1521,9 @@ static void vboxNetFltLinuxReportNicGsoCapabilities(PVBOXNETFLTINS pThis)
                 fGsoCapabilites |= RT_BIT_32(PDMNETWORKGSOTYPE_IPV4_TCP);
             if (fFeatures & NETIF_F_TSO6)
                 fGsoCapabilites |= RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_TCP);
-# if 0 /** @todo GSO: Test UDP offloading (UFO) on linux. */
-            if (fFeatures & NETIF_F_UFO)
-                fGsoCapabilites |= RT_BIT_32(PDMNETWORKGSOTYPE_IPV4_UDP);
-            if (fFeatures & NETIF_F_UFO)
-                fGsoCapabilites |= RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_UDP);
-# endif
             Log3(("vboxNetFltLinuxReportNicGsoCapabilities: reporting wire %s%s%s%s\n",
                   (fGsoCapabilites & RT_BIT_32(PDMNETWORKGSOTYPE_IPV4_TCP)) ? "tso " : "",
-                  (fGsoCapabilites & RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_TCP)) ? "tso6 " : "",
-                  (fGsoCapabilites & RT_BIT_32(PDMNETWORKGSOTYPE_IPV4_UDP)) ? "ufo " : "",
-                  (fGsoCapabilites & RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_UDP)) ? "ufo6 " : ""));
+                  (fGsoCapabilites & RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_TCP)) ? "tso6 " : ""));
             pThis->pSwitchPort->pfnReportGsoCapabilities(pThis->pSwitchPort, fGsoCapabilites, INTNETTRUNKDIR_WIRE);
         }
 
@@ -2227,15 +2216,11 @@ int  vboxNetFltOsConnectIt(PVBOXNETFLTINS pThis)
      */
     /** @todo duplicate work here now? Attach */
 #if defined(VBOXNETFLT_WITH_GSO_XMIT_HOST)
-    Log3(("vboxNetFltOsConnectIt: reporting host tso tso6 ufo\n"));
+    Log3(("vboxNetFltOsConnectIt: reporting host tso tso6\n"));
     pThis->pSwitchPort->pfnReportGsoCapabilities(pThis->pSwitchPort,
                                                  0
                                                  | RT_BIT_32(PDMNETWORKGSOTYPE_IPV4_TCP)
                                                  | RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_TCP)
-                                                 | RT_BIT_32(PDMNETWORKGSOTYPE_IPV4_UDP)
-# if 0 /** @todo GSO: Test UDP offloading (UFO) on linux. */
-                                                 | RT_BIT_32(PDMNETWORKGSOTYPE_IPV6_UDP)
-# endif
                                                  , INTNETTRUNKDIR_HOST);
 
 #endif
diff --git a/src/VBox/HostDrivers/VBoxPci/linux/VBoxPci-linux.c b/src/VBox/HostDrivers/VBoxPci/linux/VBoxPci-linux.c
index 85d794846a..f83c5a00a4 100644
--- a/src/VBox/HostDrivers/VBoxPci/linux/VBoxPci-linux.c
+++ b/src/VBox/HostDrivers/VBoxPci/linux/VBoxPci-linux.c
@@ -357,7 +357,11 @@ static int vboxPciFileWrite(struct file* file, unsigned long long offset, unsign
 
     fs_save = get_fs();
     set_fs(get_ds());
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+    ret = kernel_write(file, data, size, &offset);
+#else
     ret = vfs_write(file, data, size, &offset);
+#endif
     set_fs(fs_save);
     if (ret < 0)
         printk(KERN_DEBUG "vboxPciFileWrite: error %d\n", ret);
